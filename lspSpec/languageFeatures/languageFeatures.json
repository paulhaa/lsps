{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "CallHierarchyClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether implementation supports dynamic registration. If this is set to `true` the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)` return value for the corresponding server capability as well.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "CallHierarchyIncomingCall": {
      "additionalProperties": false,
      "properties": {
        "from": {
          "$ref": "#/definitions/CallHierarchyItem",
          "description": "The item that makes the call."
        },
        "fromRanges": {
          "description": "The ranges at which the calls appear. This is relative to the caller denoted by [`this.from`](#CallHierarchyIncomingCall.from).",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/Range"
          },
          "type": "array"
        }
      },
      "required": [
        "from",
        "fromRanges"
      ],
      "type": "object"
    },
    "CallHierarchyIncomingCallsParams": {
      "additionalProperties": false,
      "properties": {
        "item": {
          "$ref": "#/definitions/CallHierarchyItem"
        },
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "item"
      ],
      "type": "object"
    },
    "CallHierarchyItem": {
      "additionalProperties": false,
      "properties": {
        "data": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/LSPAny",
          "description": "A data entry field that is preserved between a call hierarchy prepare and incoming calls or outgoing calls requests."
        },
        "detail": {
          "description": "More detail for this item, e.g. the signature of a function.",
          "type": "string"
        },
        "kind": {
          "$ref": "#/definitions/SymbolKind",
          "description": "The kind of this item."
        },
        "name": {
          "description": "The name of this item.",
          "type": "string"
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code."
        },
        "selectionRange": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function. Must be contained by the [`range`](#CallHierarchyItem.range)."
        },
        "tags": {
          "description": "Tags for this item.",
          "items": {
            "$ref": "#/definitions/SymbolTag"
          },
          "type": "array"
        },
        "uri": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentUri",
          "description": "The resource identifier of this item."
        }
      },
      "required": [
        "name",
        "kind",
        "uri",
        "range",
        "selectionRange"
      ],
      "type": "object"
    },
    "CallHierarchyOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "CallHierarchyOutgoingCall": {
      "additionalProperties": false,
      "properties": {
        "fromRanges": {
          "description": "The range at which this item is called. This is the range relative to the caller, e.g the item passed to `callHierarchy/outgoingCalls` request.",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/Range"
          },
          "type": "array"
        },
        "to": {
          "$ref": "#/definitions/CallHierarchyItem",
          "description": "The item that is called."
        }
      },
      "required": [
        "to",
        "fromRanges"
      ],
      "type": "object"
    },
    "CallHierarchyOutgoingCallsParams": {
      "additionalProperties": false,
      "properties": {
        "item": {
          "$ref": "#/definitions/CallHierarchyItem"
        },
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "item"
      ],
      "type": "object"
    },
    "CallHierarchyPrepareParams": {
      "additionalProperties": false,
      "properties": {
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "CallHierarchyRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "id": {
          "description": "The id used to register the request. The id can be used to deregister the request again. See also Registration#id.",
          "type": "string"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "CodeAction": {
      "additionalProperties": false,
      "description": "A code action represents a change that can be performed in code, e.g. to fix a problem or to refactor code.\n\nA CodeAction must set either `edit` and/or a `command`. If both are supplied, the `edit` is applied first, then the `command` is executed.",
      "properties": {
        "command": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Command",
          "description": "A command this code action executes. If a code action provides an edit and a command, first the edit is executed and then the command."
        },
        "data": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/LSPAny",
          "description": "A data entry field that is preserved on a code action between a `textDocument/codeAction` and a `codeAction/resolve` request."
        },
        "diagnostics": {
          "description": "The diagnostics that this code action resolves.",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/Diagnostic"
          },
          "type": "array"
        },
        "disabled": {
          "additionalProperties": false,
          "description": "Marks that the code action cannot currently be applied.\n\nClients should follow the following guidelines regarding disabled code actions:\n\n- Disabled code actions are not shown in automatic lightbulbs code   action menus.\n\n- Disabled actions are shown as faded out in the code action menu when   the user request a more specific type of code action, such as   refactorings.\n\n- If the user has a keybinding that auto applies a code action and only   a disabled code actions are returned, the client should show the user   an error message with `reason` in the editor.",
          "properties": {
            "reason": {
              "description": "Human readable description of why the code action is currently disabled.\n\nThis is displayed in the code actions UI.",
              "type": "string"
            }
          },
          "required": [
            "reason"
          ],
          "type": "object"
        },
        "edit": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/WorkspaceEdit",
          "description": "The workspace edit this code action performs."
        },
        "isPreferred": {
          "description": "Marks this as a preferred action. Preferred actions are used by the `auto fix` command and can be targeted by keybindings.\n\nA quick fix should be marked preferred if it properly addresses the underlying error. A refactoring should be marked preferred if it is the most reasonable choice of actions to take.",
          "type": "boolean"
        },
        "kind": {
          "$ref": "#/definitions/CodeActionKind",
          "description": "The kind of the code action.\n\nUsed to filter code actions."
        },
        "title": {
          "description": "A short, human-readable, title for this code action.",
          "type": "string"
        }
      },
      "required": [
        "title"
      ],
      "type": "object"
    },
    "CodeActionClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "codeActionLiteralSupport": {
          "additionalProperties": false,
          "description": "The client supports code action literals as a valid response of the `textDocument/codeAction` request.",
          "properties": {
            "codeActionKind": {
              "additionalProperties": false,
              "description": "The code action kind is supported with the following value set.",
              "properties": {
                "valueSet": {
                  "description": "The code action kind values the client supports. When this property exists the client also guarantees that it will handle values outside its set gracefully and falls back to a default value when unknown.",
                  "items": {
                    "$ref": "#/definitions/CodeActionKind"
                  },
                  "type": "array"
                }
              },
              "required": [
                "valueSet"
              ],
              "type": "object"
            }
          },
          "required": [
            "codeActionKind"
          ],
          "type": "object"
        },
        "dataSupport": {
          "description": "Whether code action supports the `data` property which is preserved between a `textDocument/codeAction` and a `codeAction/resolve` request.",
          "type": "boolean"
        },
        "disabledSupport": {
          "description": "Whether code action supports the `disabled` property.",
          "type": "boolean"
        },
        "dynamicRegistration": {
          "description": "Whether code action supports dynamic registration.",
          "type": "boolean"
        },
        "honorsChangeAnnotations": {
          "description": "Whether the client honors the change annotations in text edits and resource operations returned via the `CodeAction#edit` property by for example presenting the workspace edit in the user interface and asking for confirmation.",
          "type": "boolean"
        },
        "isPreferredSupport": {
          "description": "Whether code action supports the `isPreferred` property.",
          "type": "boolean"
        },
        "resolveSupport": {
          "additionalProperties": false,
          "description": "Whether the client supports resolving additional code action properties via a separate `codeAction/resolve` request.",
          "properties": {
            "properties": {
              "description": "The properties that a client can resolve lazily.",
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "required": [
            "properties"
          ],
          "type": "object"
        }
      },
      "type": "object"
    },
    "CodeActionContext": {
      "additionalProperties": false,
      "description": "Contains additional diagnostic information about the context in which a code action is run.",
      "properties": {
        "diagnostics": {
          "description": "An array of diagnostics known on the client side overlapping the range provided to the `textDocument/codeAction` request. They are provided so that the server knows which errors are currently presented to the user for the given range. There is no guarantee that these accurately reflect the error state of the resource. The primary parameter to compute code actions is the provided range.",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/Diagnostic"
          },
          "type": "array"
        },
        "only": {
          "description": "Requested kind of actions to return.\n\nActions not of this kind are filtered out by the client before being shown. So servers can omit computing them.",
          "items": {
            "$ref": "#/definitions/CodeActionKind"
          },
          "type": "array"
        },
        "triggerKind": {
          "$ref": "#/definitions/CodeActionTriggerKind",
          "description": "The reason why code actions were requested."
        }
      },
      "required": [
        "diagnostics"
      ],
      "type": "object"
    },
    "CodeActionKind": {
      "description": "The kind of a code action.\n\nKinds are a hierarchical list of identifiers separated by `.`, e.g. `\"refactor.extract.function\"`.\n\nThe set of kinds is open and client needs to announce the kinds it supports to the server during initialization.   A set of predefined code action kinds.",
      "type": "string"
    },
    "CodeActionOptions": {
      "additionalProperties": false,
      "properties": {
        "codeActionKinds": {
          "description": "CodeActionKinds that this server may return.\n\nThe list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server may list out every specific kind they provide.",
          "items": {
            "$ref": "#/definitions/CodeActionKind"
          },
          "type": "array"
        },
        "resolveProvider": {
          "description": "The server provides support to resolve additional information for a code action.",
          "type": "boolean"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "CodeActionParams": {
      "additionalProperties": false,
      "description": "Params for the CodeActionRequest",
      "properties": {
        "context": {
          "$ref": "#/definitions/CodeActionContext",
          "description": "Context carrying additional information."
        },
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range for which the command was invoked."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The document in which the command was invoked."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument",
        "range",
        "context"
      ],
      "type": "object"
    },
    "CodeActionRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "codeActionKinds": {
          "description": "CodeActionKinds that this server may return.\n\nThe list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server may list out every specific kind they provide.",
          "items": {
            "$ref": "#/definitions/CodeActionKind"
          },
          "type": "array"
        },
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "resolveProvider": {
          "description": "The server provides support to resolve additional information for a code action.",
          "type": "boolean"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "CodeActionTriggerKind": {
      "description": "The reason why code actions were requested.",
      "enum": [
        1,
        2
      ],
      "type": "number"
    },
    "CodeLens": {
      "additionalProperties": false,
      "description": "A code lens represents a command that should be shown along with source text, like the number of references, a way to run tests, etc.\n\nA code lens is _unresolved_ when no command is associated to it. For performance reasons the creation of a code lens and resolving should be done in two stages.",
      "properties": {
        "command": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Command",
          "description": "The command this code lens represents."
        },
        "data": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/LSPAny",
          "description": "A data entry field that is preserved on a code lens item between a code lens and a code lens resolve request."
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range in which this code lens is valid. Should only span a single line."
        }
      },
      "required": [
        "range"
      ],
      "type": "object"
    },
    "CodeLensClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether code lens supports dynamic registration.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "CodeLensOptions": {
      "additionalProperties": false,
      "properties": {
        "resolveProvider": {
          "description": "Code lens has a resolve provider as well.",
          "type": "boolean"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "CodeLensParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The document to request code lens for."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument"
      ],
      "type": "object"
    },
    "CodeLensRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "resolveProvider": {
          "description": "Code lens has a resolve provider as well.",
          "type": "boolean"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "CodeLensWorkspaceClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "refreshSupport": {
          "description": "Whether the client implementation supports a refresh request sent from the server to the client.\n\nNote that this event is global and will force the client to refresh all code lenses currently shown. It should be used with absolute care and is useful for situation where a server for example detect a project wide change that requires such a calculation.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "Color": {
      "additionalProperties": false,
      "description": "Represents a color in RGBA space.",
      "properties": {
        "alpha": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/decimal",
          "description": "The alpha component of this color in the range [0-1]."
        },
        "blue": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/decimal",
          "description": "The blue component of this color in the range [0-1]."
        },
        "green": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/decimal",
          "description": "The green component of this color in the range [0-1]."
        },
        "red": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/decimal",
          "description": "The red component of this color in the range [0-1]."
        }
      },
      "required": [
        "red",
        "green",
        "blue",
        "alpha"
      ],
      "type": "object"
    },
    "ColorInformation": {
      "additionalProperties": false,
      "properties": {
        "color": {
          "$ref": "#/definitions/Color",
          "description": "The actual color value for this color range."
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range in the document where this color appears."
        }
      },
      "required": [
        "range",
        "color"
      ],
      "type": "object"
    },
    "ColorPresentation": {
      "additionalProperties": false,
      "properties": {
        "additionalTextEdits": {
          "description": "An optional array of additional [text edits](#TextEdit) that are applied when selecting this color presentation. Edits must not overlap with the main [edit](#ColorPresentation.textEdit) nor with themselves.",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/TextEdit"
          },
          "type": "array"
        },
        "label": {
          "description": "The label of this color presentation. It will be shown on the color picker header. By default this is also the text that is inserted when selecting this color presentation.",
          "type": "string"
        },
        "textEdit": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextEdit",
          "description": "An [edit](#TextEdit) which is applied to a document when selecting this presentation for the color. When omitted the [label](#ColorPresentation.label) is used."
        }
      },
      "required": [
        "label"
      ],
      "type": "object"
    },
    "ColorPresentationParams": {
      "additionalProperties": false,
      "properties": {
        "color": {
          "$ref": "#/definitions/Color",
          "description": "The color information to request presentations for."
        },
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range where the color would be inserted. Serves as a context."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument",
        "color",
        "range"
      ],
      "type": "object"
    },
    "CompletionClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "completionItem": {
          "additionalProperties": false,
          "description": "The client supports the following `CompletionItem` specific capabilities.",
          "properties": {
            "commitCharactersSupport": {
              "description": "Client supports commit characters on a completion item.",
              "type": "boolean"
            },
            "deprecatedSupport": {
              "description": "Client supports the deprecated property on a completion item.",
              "type": "boolean"
            },
            "documentationFormat": {
              "description": "Client supports the follow content formats for the documentation property. The order describes the preferred format of the client.",
              "items": {
                "$ref": "../basicStructures/basicStructures.json#/definitions/MarkupKind"
              },
              "type": "array"
            },
            "insertReplaceSupport": {
              "description": "Client supports insert replace edit to control different behavior if a completion item is inserted in the text or should replace text.",
              "type": "boolean"
            },
            "insertTextModeSupport": {
              "additionalProperties": false,
              "description": "The client supports the `insertTextMode` property on a completion item to override the whitespace handling mode as defined by the client (see `insertTextMode`).",
              "properties": {
                "valueSet": {
                  "items": {
                    "$ref": "#/definitions/InsertTextMode"
                  },
                  "type": "array"
                }
              },
              "required": [
                "valueSet"
              ],
              "type": "object"
            },
            "labelDetailsSupport": {
              "description": "The client has support for completion item label details (see also `CompletionItemLabelDetails`).",
              "type": "boolean"
            },
            "preselectSupport": {
              "description": "Client supports the preselect property on a completion item.",
              "type": "boolean"
            },
            "resolveSupport": {
              "additionalProperties": false,
              "description": "Indicates which properties a client can resolve lazily on a completion item. Before version 3.16.0 only the predefined properties `documentation` and `detail` could be resolved lazily.",
              "properties": {
                "properties": {
                  "description": "The properties that a client can resolve lazily.",
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                }
              },
              "required": [
                "properties"
              ],
              "type": "object"
            },
            "snippetSupport": {
              "description": "Client supports snippets as insert text.\n\nA snippet can define tab stops and placeholders with `$1`, `$2` and `${3:foo}`. `$0` defines the final tab stop, it defaults to the end of the snippet. Placeholders with equal identifiers are linked, that is typing in one will update others too.",
              "type": "boolean"
            },
            "tagSupport": {
              "additionalProperties": false,
              "description": "Client supports the tag property on a completion item. Clients supporting tags have to handle unknown tags gracefully. Clients especially need to preserve unknown tags when sending a completion item back to the server in a resolve call.",
              "properties": {
                "valueSet": {
                  "description": "The tags supported by the client.",
                  "items": {
                    "$ref": "#/definitions/CompletionItemTag"
                  },
                  "type": "array"
                }
              },
              "required": [
                "valueSet"
              ],
              "type": "object"
            }
          },
          "type": "object"
        },
        "completionItemKind": {
          "additionalProperties": false,
          "properties": {
            "valueSet": {
              "description": "The completion item kind values the client supports. When this property exists the client also guarantees that it will handle values outside its set gracefully and falls back to a default value when unknown.\n\nIf this property is not present the client only supports the completion items kinds from `Text` to `Reference` as defined in the initial version of the protocol.",
              "items": {
                "$ref": "#/definitions/CompletionItemKind"
              },
              "type": "array"
            }
          },
          "type": "object"
        },
        "completionList": {
          "additionalProperties": false,
          "description": "The client supports the following `CompletionList` specific capabilities.",
          "properties": {
            "itemDefaults": {
              "description": "The client supports the following itemDefaults on a completion list.\n\nThe value lists the supported property names of the `CompletionList.itemDefaults` object. If omitted no properties are supported.",
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "type": "object"
        },
        "contextSupport": {
          "description": "The client supports to send additional context information for a `textDocument/completion` request.",
          "type": "boolean"
        },
        "dynamicRegistration": {
          "description": "Whether completion supports dynamic registration.",
          "type": "boolean"
        },
        "insertTextMode": {
          "$ref": "#/definitions/InsertTextMode",
          "description": "The client's default when the completion item doesn't provide a `insertTextMode` property."
        }
      },
      "type": "object"
    },
    "CompletionContext": {
      "additionalProperties": false,
      "description": "Contains additional information about the context in which a completion request is triggered.",
      "properties": {
        "triggerCharacter": {
          "description": "The trigger character (a single character) that has trigger code complete. Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`",
          "type": "string"
        },
        "triggerKind": {
          "$ref": "#/definitions/CompletionTriggerKind",
          "description": "How the completion was triggered."
        }
      },
      "required": [
        "triggerKind"
      ],
      "type": "object"
    },
    "CompletionItem": {
      "additionalProperties": false,
      "properties": {
        "additionalTextEdits": {
          "description": "An optional array of additional text edits that are applied when selecting this completion. Edits must not overlap (including the same insert position) with the main edit nor with themselves.\n\nAdditional text edits should be used to change text unrelated to the current cursor position (for example adding an import statement at the top of the file if the completion item will insert an unqualified type).",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/TextEdit"
          },
          "type": "array"
        },
        "command": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Command",
          "description": "An optional command that is executed *after* inserting this completion.\n*Note* that additional modifications to the current document should be described with the additionalTextEdits-property."
        },
        "commitCharacters": {
          "description": "An optional set of characters that when pressed while this completion is active will accept it first and then type that character. *Note* that all commit characters should have `length=1` and that superfluous characters will be ignored.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "data": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/LSPAny",
          "description": "A data entry field that is preserved on a completion item between a completion and a completion resolve request."
        },
        "deprecated": {
          "deprecated": "Use `tags` instead if supported.",
          "description": "Indicates if this item is deprecated.",
          "type": "boolean"
        },
        "detail": {
          "description": "A human-readable string with additional information about this item, like type or symbol information.",
          "type": "string"
        },
        "documentation": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/MarkupContent"
            }
          ],
          "description": "A human-readable string that represents a doc-comment."
        },
        "filterText": {
          "description": "A string that should be used when filtering a set of completion items. When omitted the label is used as the filter text for this item.",
          "type": "string"
        },
        "insertText": {
          "description": "A string that should be inserted into a document when selecting this completion. When omitted the label is used as the insert text for this item.\n\nThe `insertText` is subject to interpretation by the client side. Some tools might not take the string literally. For example VS Code when code complete is requested in this example `con&lt;cursor position&gt;` and a completion item with an `insertText` of `console` is provided it will only insert `sole`. Therefore it is recommended to use `textEdit` instead since it avoids additional client side interpretation.",
          "type": "string"
        },
        "insertTextFormat": {
          "$ref": "#/definitions/InsertTextFormat",
          "description": "The format of the insert text. The format applies to both the `insertText` property and the `newText` property of a provided `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.\n\nPlease note that the insertTextFormat doesn't apply to `additionalTextEdits`."
        },
        "insertTextMode": {
          "$ref": "#/definitions/InsertTextMode",
          "description": "How whitespace and indentation is handled during completion item insertion. If not provided the client's default value depends on the `textDocument.completion.insertTextMode` client capability."
        },
        "kind": {
          "$ref": "#/definitions/CompletionItemKind",
          "description": "The kind of this completion item. Based of the kind an icon is chosen by the editor. The standardized set of available values is defined in `CompletionItemKind`."
        },
        "label": {
          "description": "The label of this completion item.\n\nThe label property is also by default the text that is inserted when selecting this completion.\n\nIf label details are provided the label itself should be an unqualified name of the completion item.",
          "type": "string"
        },
        "labelDetails": {
          "$ref": "#/definitions/CompletionItemLabelDetails",
          "description": "Additional details for the label"
        },
        "preselect": {
          "description": "Select this item when showing.\n\n*Note* that only one completion item can be selected and that the tool / client decides which item that is. The rule is that the *first* item of those that match best is selected.",
          "type": "boolean"
        },
        "sortText": {
          "description": "A string that should be used when comparing this item with other items. When omitted the label is used as the sort text for this item.",
          "type": "string"
        },
        "tags": {
          "description": "Tags for this completion item.",
          "items": {
            "$ref": "#/definitions/CompletionItemTag"
          },
          "type": "array"
        },
        "textEdit": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/TextEdit"
            },
            {
              "$ref": "#/definitions/InsertReplaceEdit"
            }
          ],
          "description": "An edit which is applied to a document when selecting this completion. When an edit is provided the value of `insertText` is ignored.\n\n*Note:* The range of the edit must be a single line range and it must contain the position at which completion has been requested.\n\nMost editors support two different operations when accepting a completion item. One is to insert a completion text and the other is to replace an existing text with a completion text. Since this can usually not be predetermined by a server it can report both ranges. Clients need to signal support for `InsertReplaceEdit`s via the `textDocument.completion.completionItem.insertReplaceSupport` client capability property.\n\n*Note 1:* The text edit's range as well as both ranges from an insert replace edit must be a [single line] and they must contain the position at which completion has been requested.\n*Note 2:* If an `InsertReplaceEdit` is returned the edit's insert range must be a prefix of the edit's replace range, that means it must be contained and starting at the same position."
        },
        "textEditText": {
          "description": "The edit text used if the completion item is part of a CompletionList and CompletionList defines an item default for the text edit range.\n\nClients will only honor this property if they opt into completion list item defaults using the capability `completionList.itemDefaults`.\n\nIf not provided and a list's default range is provided the label property is used as a text.",
          "type": "string"
        }
      },
      "required": [
        "label"
      ],
      "type": "object"
    },
    "CompletionItemKind": {
      "description": "The kind of a completion entry.",
      "enum": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25
      ],
      "type": "number"
    },
    "CompletionItemLabelDetails": {
      "additionalProperties": false,
      "description": "Additional details for a completion item label.",
      "properties": {
        "description": {
          "description": "An optional string which is rendered less prominently after  {@link  CompletionItemLabelDetails.detail } . Should be used for fully qualified names or file path.",
          "type": "string"
        },
        "detail": {
          "description": "An optional string which is rendered less prominently directly after  {@link  CompletionItem.label label } , without any spacing. Should be used for function signatures or type annotations.",
          "type": "string"
        }
      },
      "type": "object"
    },
    "CompletionItemTag": {
      "enum": [
        1
      ],
      "description": "Completion item tags are extra annotations that tweak the rendering of a completion item.",
      "type": "number"
    },
    "CompletionList": {
      "additionalProperties": false,
      "description": "Represents a collection of [completion items](#CompletionItem) to be presented in the editor.",
      "properties": {
        "isIncomplete": {
          "description": "This list is not complete. Further typing should result in recomputing this list.\n\nRecomputed lists have all their items replaced (not appended) in the incomplete completion sessions.",
          "type": "boolean"
        },
        "itemDefaults": {
          "additionalProperties": false,
          "description": "In many cases the items of an actual completion result share the same value for properties like `commitCharacters` or the range of a text edit. A completion list can therefore define item defaults which will be used if a completion item itself doesn't specify the value.\n\nIf a completion list specifies a default value and a completion item also specifies a corresponding value the one from the item is used.\n\nServers are only allowed to return default values if the client signals support for this via the `completionList.itemDefaults` capability.",
          "properties": {
            "commitCharacters": {
              "description": "A default commit character set.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "data": {
              "$ref": "../baseProtocol/baseProtocol.json#/definitions/LSPAny",
              "description": "A default data value."
            },
            "editRange": {
              "anyOf": [
                {
                  "$ref": "../basicStructures/basicStructures.json#/definitions/Range"
                },
                {
                  "additionalProperties": false,
                  "properties": {
                    "insert": {
                      "$ref": "../basicStructures/basicStructures.json#/definitions/Range"
                    },
                    "replace": {
                      "$ref": "../basicStructures/basicStructures.json#/definitions/Range"
                    }
                  },
                  "required": [
                    "insert",
                    "replace"
                  ],
                  "type": "object"
                }
              ],
              "description": "A default edit range"
            },
            "insertTextFormat": {
              "$ref": "#/definitions/InsertTextFormat",
              "description": "A default insert text format"
            },
            "insertTextMode": {
              "$ref": "#/definitions/InsertTextMode",
              "description": "A default insert text mode"
            }
          },
          "type": "object"
        },
        "items": {
          "description": "The completion items.",
          "items": {
            "$ref": "#/definitions/CompletionItem"
          },
          "type": "array"
        }
      },
      "required": [
        "isIncomplete",
        "items"
      ],
      "type": "object"
    },
    "CompletionOptions": {
      "additionalProperties": false,
      "description": "Completion options.",
      "properties": {
        "allCommitCharacters": {
          "description": "The list of all possible characters that commit a completion. This field can be used if clients don't support individual commit characters per completion item. See client capability `completion.completionItem.commitCharactersSupport`.\n\nIf a server provides both `allCommitCharacters` and commit characters on an individual completion item the ones on the completion item win.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "completionItem": {
          "additionalProperties": false,
          "description": "The server supports the following `CompletionItem` specific capabilities.",
          "properties": {
            "labelDetailsSupport": {
              "description": "The server has support for completion item label details (see also `CompletionItemLabelDetails`) when receiving a completion item in a resolve call.",
              "type": "boolean"
            }
          },
          "type": "object"
        },
        "resolveProvider": {
          "description": "The server provides support to resolve additional information for a completion item.",
          "type": "boolean"
        },
        "triggerCharacters": {
          "description": "The additional characters, beyond the defaults provided by the client (typically [a-zA-Z]), that should automatically trigger a completion request. For example `.` in JavaScript represents the beginning of an object property or method and is thus a good candidate for triggering a completion request.\n\nMost tools trigger a completion request automatically without explicitly requesting it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user starts to type an identifier. For example if the user types `c` in a JavaScript file code complete will automatically pop up present `console` besides others as a completion item. Characters that make up identifiers don't need to be listed here.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "CompletionParams": {
      "additionalProperties": false,
      "properties": {
        "context": {
          "$ref": "#/definitions/CompletionContext",
          "description": "The completion context. This is only available if the client specifies to send this using the client capability `completion.contextSupport === true`"
        },
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "CompletionRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "allCommitCharacters": {
          "description": "The list of all possible characters that commit a completion. This field can be used if clients don't support individual commit characters per completion item. See client capability `completion.completionItem.commitCharactersSupport`.\n\nIf a server provides both `allCommitCharacters` and commit characters on an individual completion item the ones on the completion item win.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "completionItem": {
          "additionalProperties": false,
          "description": "The server supports the following `CompletionItem` specific capabilities.",
          "properties": {
            "labelDetailsSupport": {
              "description": "The server has support for completion item label details (see also `CompletionItemLabelDetails`) when receiving a completion item in a resolve call.",
              "type": "boolean"
            }
          },
          "type": "object"
        },
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "resolveProvider": {
          "description": "The server provides support to resolve additional information for a completion item.",
          "type": "boolean"
        },
        "triggerCharacters": {
          "description": "The additional characters, beyond the defaults provided by the client (typically [a-zA-Z]), that should automatically trigger a completion request. For example `.` in JavaScript represents the beginning of an object property or method and is thus a good candidate for triggering a completion request.\n\nMost tools trigger a completion request automatically without explicitly requesting it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user starts to type an identifier. For example if the user types `c` in a JavaScript file code complete will automatically pop up present `console` besides others as a completion item. Characters that make up identifiers don't need to be listed here.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "CompletionTriggerKind": {
      "description": "How a completion was triggered",
      "enum": [
        1,
        2,
        3
      ],
      "type": "number"
    },
    "DeclarationClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether declaration supports dynamic registration. If this is set to `true` the client supports the new `DeclarationRegistrationOptions` return value for the corresponding server capability as well.",
          "type": "boolean"
        },
        "linkSupport": {
          "description": "The client supports additional metadata in the form of declaration links.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DeclarationOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DeclarationParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "DeclarationRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "id": {
          "description": "The id used to register the request. The id can be used to deregister the request again. See also Registration#id.",
          "type": "string"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "DefinitionClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether definition supports dynamic registration.",
          "type": "boolean"
        },
        "linkSupport": {
          "description": "The client supports additional metadata in the form of definition links.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DefinitionOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DefinitionParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "DefinitionRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "DiagnosticClientCapabilities": {
      "additionalProperties": false,
      "description": "Client capabilities specific to diagnostic pull requests.",
      "properties": {
        "dynamicRegistration": {
          "description": "Whether implementation supports dynamic registration. If this is set to `true` the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)` return value for the corresponding server capability as well.",
          "type": "boolean"
        },
        "relatedDocumentSupport": {
          "description": "Whether the clients supports related documents for document diagnostic pulls.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DiagnosticOptions": {
      "additionalProperties": false,
      "description": "Diagnostic options.",
      "properties": {
        "identifier": {
          "description": "An optional identifier under which the diagnostics are managed by the client.",
          "type": "string"
        },
        "interFileDependencies": {
          "description": "Whether the language has inter file dependencies meaning that editing code in one file can result in a different diagnostic set in another file. Inter file dependencies are common for most programming languages and typically uncommon for linters.",
          "type": "boolean"
        },
        "workDoneProgress": {
          "type": "boolean"
        },
        "workspaceDiagnostics": {
          "description": "The server provides support for workspace diagnostics as well.",
          "type": "boolean"
        }
      },
      "required": [
        "interFileDependencies",
        "workspaceDiagnostics"
      ],
      "type": "object"
    },
    "DiagnosticRegistrationOptions": {
      "additionalProperties": false,
      "description": "Diagnostic registration options.",
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "id": {
          "description": "The id used to register the request. The id can be used to deregister the request again. See also Registration#id.",
          "type": "string"
        },
        "identifier": {
          "description": "An optional identifier under which the diagnostics are managed by the client.",
          "type": "string"
        },
        "interFileDependencies": {
          "description": "Whether the language has inter file dependencies meaning that editing code in one file can result in a different diagnostic set in another file. Inter file dependencies are common for most programming languages and typically uncommon for linters.",
          "type": "boolean"
        },
        "workDoneProgress": {
          "type": "boolean"
        },
        "workspaceDiagnostics": {
          "description": "The server provides support for workspace diagnostics as well.",
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector",
        "interFileDependencies",
        "workspaceDiagnostics"
      ],
      "type": "object"
    },
    "DiagnosticServerCancellationData": {
      "additionalProperties": false,
      "description": "Cancellation data returned from a diagnostic request.",
      "properties": {
        "retriggerRequest": {
          "type": "boolean"
        }
      },
      "required": [
        "retriggerRequest"
      ],
      "type": "object"
    },
    "DiagnosticWorkspaceClientCapabilities": {
      "additionalProperties": false,
      "description": "Workspace client capabilities specific to diagnostic pull requests.",
      "properties": {
        "refreshSupport": {
          "description": "Whether the client implementation supports a refresh request sent from the server to the client.\n\nNote that this event is global and will force the client to refresh all pulled diagnostics currently shown. It should be used with absolute care and is useful for situation where a server for example detects a project wide change that requires such a calculation.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentColorClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether document color supports dynamic registration.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentColorOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentColorParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument"
      ],
      "type": "object"
    },
    "DocumentColorRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "id": {
          "description": "The id used to register the request. The id can be used to deregister the request again. See also Registration#id.",
          "type": "string"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "DocumentDiagnosticParams": {
      "additionalProperties": false,
      "description": "Parameters of the document diagnostic request.",
      "properties": {
        "identifier": {
          "description": "The additional identifier  provided during registration.",
          "type": "string"
        },
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "previousResultId": {
          "description": "The result id of a previous response if provided.",
          "type": "string"
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument"
      ],
      "type": "object"
    },
    "DocumentDiagnosticReport": {
      "anyOf": [
        {
          "$ref": "#/definitions/RelatedFullDocumentDiagnosticReport"
        },
        {
          "$ref": "#/definitions/RelatedUnchangedDocumentDiagnosticReport"
        }
      ],
      "description": "The result of a document diagnostic pull request. A report can either be a full report containing all diagnostics for the requested document or a unchanged report indicating that nothing has changed in terms of diagnostics in comparison to the last pull request."
    },
    "DocumentDiagnosticReportKind": {
      "description": "The document diagnostic report kinds.",
      "enum": [
        "full",
        "unchanged"
      ],
      "type": "string"
    },
    "DocumentDiagnosticReportPartialResult": {
      "additionalProperties": false,
      "description": "A partial result for a document diagnostic report.",
      "properties": {
        "relatedDocuments": {
          "additionalProperties": {
            "anyOf": [
              {
                "$ref": "#/definitions/FullDocumentDiagnosticReport"
              },
              {
                "$ref": "#/definitions/UnchangedDocumentDiagnosticReport"
              }
            ]
          },
          "type": "object"
        }
      },
      "required": [
        "relatedDocuments"
      ],
      "type": "object"
    },
    "DocumentFormattingClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether formatting supports dynamic registration.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentFormattingOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentFormattingParams": {
      "additionalProperties": false,
      "properties": {
        "options": {
          "$ref": "#/definitions/FormattingOptions",
          "description": "The format options."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The document to format."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument",
        "options"
      ],
      "type": "object"
    },
    "DocumentFormattingRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "DocumentHighlight": {
      "additionalProperties": false,
      "description": "A document highlight is a range inside a text document which deserves special attention. Usually a document highlight is visualized by changing the background color of its range.",
      "properties": {
        "kind": {
          "$ref": "#/definitions/DocumentHighlightKind",
          "description": "The highlight kind, default is DocumentHighlightKind.Text."
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range this highlight applies to."
        }
      },
      "required": [
        "range"
      ],
      "type": "object"
    },
    "DocumentHighlightClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether document highlight supports dynamic registration.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentHighlightKind": {
      "description": "A document highlight kind.",
      "enum": [
        1,
        2,
        3
      ],
      "type": "number"
    },
    "DocumentHighlightOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentHighlightParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "DocumentHighlightRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "DocumentLink": {
      "additionalProperties": false,
      "description": "A document link is a range in a text document that links to an internal or external resource, like another text document or a web site.",
      "properties": {
        "data": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/LSPAny",
          "description": "A data entry field that is preserved on a document link between a DocumentLinkRequest and a DocumentLinkResolveRequest."
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range this link applies to."
        },
        "target": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/URI",
          "description": "The uri this link points to. If missing a resolve request is sent later."
        },
        "tooltip": {
          "description": "The tooltip text when you hover over this link.\n\nIf a tooltip is provided, is will be displayed in a string that includes instructions on how to trigger the link, such as `{0} (ctrl + click)`. The specific instructions vary depending on OS, user settings, and localization.",
          "type": "string"
        }
      },
      "required": [
        "range"
      ],
      "type": "object"
    },
    "DocumentLinkClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether document link supports dynamic registration.",
          "type": "boolean"
        },
        "tooltipSupport": {
          "description": "Whether the client supports the `tooltip` property on `DocumentLink`.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentLinkOptions": {
      "additionalProperties": false,
      "properties": {
        "resolveProvider": {
          "description": "Document links have a resolve provider as well.",
          "type": "boolean"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentLinkParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The document to provide document links for."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument"
      ],
      "type": "object"
    },
    "DocumentLinkRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "resolveProvider": {
          "description": "Document links have a resolve provider as well.",
          "type": "boolean"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "DocumentOnTypeFormattingClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether on type formatting supports dynamic registration.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentOnTypeFormattingOptions": {
      "additionalProperties": false,
      "properties": {
        "firstTriggerCharacter": {
          "description": "A character on which formatting should be triggered, like `{`.",
          "type": "string"
        },
        "moreTriggerCharacter": {
          "description": "More trigger characters.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "firstTriggerCharacter"
      ],
      "type": "object"
    },
    "DocumentOnTypeFormattingParams": {
      "additionalProperties": false,
      "properties": {
        "ch": {
          "description": "The character that has been typed that triggered the formatting on type request. That is not necessarily the last character that got inserted into the document since the client could auto insert characters as well (e.g. like automatic brace completion).",
          "type": "string"
        },
        "options": {
          "$ref": "#/definitions/FormattingOptions",
          "description": "The formatting options."
        },
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position around which the on type formatting should happen. This is not necessarily the exact position where the character denoted by the property `ch` got typed."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The document to format."
        }
      },
      "required": [
        "textDocument",
        "position",
        "ch",
        "options"
      ],
      "type": "object"
    },
    "DocumentOnTypeFormattingRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "firstTriggerCharacter": {
          "description": "A character on which formatting should be triggered, like `{`.",
          "type": "string"
        },
        "moreTriggerCharacter": {
          "description": "More trigger characters.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "documentSelector",
        "firstTriggerCharacter"
      ],
      "type": "object"
    },
    "DocumentRangeFormattingClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether formatting supports dynamic registration.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentRangeFormattingOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentRangeFormattingParams": {
      "additionalProperties": false,
      "properties": {
        "options": {
          "$ref": "#/definitions/FormattingOptions",
          "description": "The format options"
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range to format"
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The document to format."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument",
        "range",
        "options"
      ],
      "type": "object"
    },
    "DocumentRangeFormattingRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "DocumentSymbol": {
      "additionalProperties": false,
      "description": "Represents programming constructs like variables, classes, interfaces etc. that appear in a document. Document symbols can be hierarchical and they have two ranges: one that encloses its definition and one that points to its most interesting range, e.g. the range of an identifier.",
      "properties": {
        "children": {
          "description": "Children of this symbol, e.g. properties of a class.",
          "items": {
            "$ref": "#/definitions/DocumentSymbol"
          },
          "type": "array"
        },
        "deprecated": {
          "deprecated": "Use tags instead",
          "description": "Indicates if this symbol is deprecated.",
          "type": "boolean"
        },
        "detail": {
          "description": "More detail for this symbol, e.g the signature of a function.",
          "type": "string"
        },
        "kind": {
          "$ref": "#/definitions/SymbolKind",
          "description": "The kind of this symbol."
        },
        "name": {
          "description": "The name of this symbol. Will be displayed in the user interface and therefore must not be an empty string or a string only consisting of white spaces.",
          "type": "string"
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range enclosing this symbol not including leading/trailing whitespace but everything else like comments. This information is typically used to determine if the clients cursor is inside the symbol to reveal in the symbol in the UI."
        },
        "selectionRange": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function. Must be contained by the `range`."
        },
        "tags": {
          "description": "Tags for this document symbol.",
          "items": {
            "$ref": "#/definitions/SymbolTag"
          },
          "type": "array"
        }
      },
      "required": [
        "name",
        "kind",
        "range",
        "selectionRange"
      ],
      "type": "object"
    },
    "DocumentSymbolClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether document symbol supports dynamic registration.",
          "type": "boolean"
        },
        "hierarchicalDocumentSymbolSupport": {
          "description": "The client supports hierarchical document symbols.",
          "type": "boolean"
        },
        "labelSupport": {
          "description": "The client supports an additional label presented in the UI when registering a document symbol provider.",
          "type": "boolean"
        },
        "symbolKind": {
          "additionalProperties": false,
          "description": "Specific capabilities for the `SymbolKind` in the `textDocument/documentSymbol` request.",
          "properties": {
            "valueSet": {
              "description": "The symbol kind values the client supports. When this property exists the client also guarantees that it will handle values outside its set gracefully and falls back to a default value when unknown.\n\nIf this property is not present the client only supports the symbol kinds from `File` to `Array` as defined in the initial version of the protocol.",
              "items": {
                "$ref": "#/definitions/SymbolKind"
              },
              "type": "array"
            }
          },
          "type": "object"
        },
        "tagSupport": {
          "additionalProperties": false,
          "description": "The client supports tags on `SymbolInformation`. Tags are supported on `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true. Clients supporting tags have to handle unknown tags gracefully.",
          "properties": {
            "valueSet": {
              "description": "The tags supported by the client.",
              "items": {
                "$ref": "#/definitions/SymbolTag"
              },
              "type": "array"
            }
          },
          "required": [
            "valueSet"
          ],
          "type": "object"
        }
      },
      "type": "object"
    },
    "DocumentSymbolOptions": {
      "additionalProperties": false,
      "properties": {
        "label": {
          "description": "A human-readable string that is shown when multiple outlines trees are shown for the same document.",
          "type": "string"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "DocumentSymbolParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument"
      ],
      "type": "object"
    },
    "DocumentSymbolRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "label": {
          "description": "A human-readable string that is shown when multiple outlines trees are shown for the same document.",
          "type": "string"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "FoldingRange": {
      "additionalProperties": false,
      "description": "Represents a folding range. To be valid, start and end line must be bigger than zero and smaller than the number of lines in the document. Clients are free to ignore invalid ranges.",
      "properties": {
        "collapsedText": {
          "description": "The text that the client should show when the specified range is collapsed. If not defined or not supported by the client, a default will be chosen by the client.",
          "type": "string"
        },
        "endCharacter": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger",
          "description": "The zero-based character offset before the folded range ends. If not defined, defaults to the length of the end line."
        },
        "endLine": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger",
          "description": "The zero-based end line of the range to fold. The folded area ends with the line's last character. To be valid, the end must be zero or larger and smaller than the number of lines in the document."
        },
        "kind": {
          "$ref": "#/definitions/FoldingRangeKind",
          "description": "Describes the kind of the folding range such as `comment` or `region`. The kind is used to categorize folding ranges and used by commands like 'Fold all comments'. See [FoldingRangeKind](#FoldingRangeKind) for an enumeration of standardized kinds."
        },
        "startCharacter": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger",
          "description": "The zero-based character offset from where the folded range starts. If not defined, defaults to the length of the start line."
        },
        "startLine": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger",
          "description": "The zero-based start line of the range to fold. The folded area starts after the line's last character. To be valid, the end must be zero or larger and smaller than the number of lines in the document."
        }
      },
      "required": [
        "startLine",
        "endLine"
      ],
      "type": "object"
    },
    "FoldingRangeClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether implementation supports dynamic registration for folding range providers. If this is set to `true` the client supports the new `FoldingRangeRegistrationOptions` return value for the corresponding server capability as well.",
          "type": "boolean"
        },
        "foldingRange": {
          "additionalProperties": false,
          "description": "Specific options for the folding range.",
          "properties": {
            "collapsedText": {
              "description": "If set, the client signals that it supports setting collapsedText on folding ranges to display custom labels instead of the default text.",
              "type": "boolean"
            }
          },
          "type": "object"
        },
        "foldingRangeKind": {
          "additionalProperties": false,
          "description": "Specific options for the folding range kind.",
          "properties": {
            "valueSet": {
              "description": "The folding range kind values the client supports. When this property exists the client also guarantees that it will handle values outside its set gracefully and falls back to a default value when unknown.",
              "items": {
                "$ref": "#/definitions/FoldingRangeKind"
              },
              "type": "array"
            }
          },
          "type": "object"
        },
        "lineFoldingOnly": {
          "description": "If set, the client signals that it only supports folding complete lines. If set, client will ignore specified `startCharacter` and `endCharacter` properties in a FoldingRange.",
          "type": "boolean"
        },
        "rangeLimit": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger",
          "description": "The maximum number of folding ranges that the client prefers to receive per document. The value serves as a hint, servers are free to follow the limit."
        }
      },
      "type": "object"
    },
    "FoldingRangeKind": {
      "description": "A set of predefined range kinds.   The type is a string since the value set is extensible",
      "type": "string"
    },
    "FoldingRangeOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "FoldingRangeParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument"
      ],
      "type": "object"
    },
    "FoldingRangeRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "id": {
          "description": "The id used to register the request. The id can be used to deregister the request again. See also Registration#id.",
          "type": "string"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "FormattingOptions": {
      "additionalProperties": {
        "anyOf": [
          {
            "type": "boolean"
          },
          {
            "$ref": "../baseProtocol/baseProtocol.json#/definitions/integer"
          },
          {
            "type": "string"
          },
          {
            "not": {}
          }
        ],
        "description": "Signature for further properties."
      },
      "description": "Value-object describing what options formatting should use.",
      "properties": {
        "insertFinalNewline": {
          "description": "Insert a newline character at the end of the file if one does not exist.",
          "type": "boolean"
        },
        "insertSpaces": {
          "description": "Prefer spaces over tabs.",
          "type": "boolean"
        },
        "tabSize": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger",
          "description": "Size of a tab in spaces."
        },
        "trimFinalNewlines": {
          "description": "Trim all newlines after the final newline at the end of the file.",
          "type": "boolean"
        },
        "trimTrailingWhitespace": {
          "description": "Trim trailing whitespace on a line.",
          "type": "boolean"
        }
      },
      "required": [
        "tabSize",
        "insertSpaces"
      ],
      "type": "object"
    },
    "FullDocumentDiagnosticReport": {
      "additionalProperties": false,
      "description": "A diagnostic report with a full set of problems.",
      "properties": {
        "items": {
          "description": "The actual items.",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/Diagnostic"
          },
          "type": "array"
        },
        "kind": {
          "enum": [
            "full"
          ],
          "description": "A full document diagnostic report.",
          "type": "string"
        },
        "resultId": {
          "description": "An optional result id. If provided it will be sent on the next diagnostic request for the same document.",
          "type": "string"
        }
      },
      "required": [
        "kind",
        "items"
      ],
      "type": "object"
    },
    "Hover": {
      "additionalProperties": false,
      "description": "The result of a hover request.",
      "properties": {
        "contents": {
          "anyOf": [
            {
              "$ref": "#/definitions/MarkedString"
            },
            {
              "items": {
                "$ref": "#/definitions/MarkedString"
              },
              "type": "array"
            },
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/MarkupContent"
            }
          ],
          "description": "The hover's content"
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "An optional range is a range inside a text document that is used to visualize a hover, e.g. by changing the background color."
        }
      },
      "required": [
        "contents"
      ],
      "type": "object"
    },
    "HoverClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "contentFormat": {
          "description": "Client supports the follow content formats if the content property refers to a `literal of type MarkupContent`. The order describes the preferred format of the client.",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/MarkupKind"
          },
          "type": "array"
        },
        "dynamicRegistration": {
          "description": "Whether hover supports dynamic registration.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "HoverOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "HoverParams": {
      "additionalProperties": false,
      "properties": {
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "HoverRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "ImplementationClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether implementation supports dynamic registration. If this is set to `true` the client supports the new `ImplementationRegistrationOptions` return value for the corresponding server capability as well.",
          "type": "boolean"
        },
        "linkSupport": {
          "description": "The client supports additional metadata in the form of definition links.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ImplementationOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ImplementationParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "ImplementationRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "id": {
          "description": "The id used to register the request. The id can be used to deregister the request again. See also Registration#id.",
          "type": "string"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "InlayHint": {
      "additionalProperties": false,
      "description": "Inlay hint information.",
      "properties": {
        "data": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/LSPAny",
          "description": "A data entry field that is preserved on an inlay hint between a `textDocument/inlayHint` and a `inlayHint/resolve` request."
        },
        "kind": {
          "$ref": "#/definitions/InlayHintKind",
          "description": "The kind of this hint. Can be omitted in which case the client should fall back to a reasonable default."
        },
        "label": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "$ref": "#/definitions/InlayHintLabelPart"
              },
              "type": "array"
            }
          ],
          "description": "The label of this hint. A human readable string or an array of InlayHintLabelPart label parts.\n\n*Note* that neither the string nor the label part can be empty."
        },
        "paddingLeft": {
          "description": "Render padding before the hint.\n\nNote: Padding should use the editor's background color, not the background color of the hint itself. That means padding can be used to visually align/separate an inlay hint.",
          "type": "boolean"
        },
        "paddingRight": {
          "description": "Render padding after the hint.\n\nNote: Padding should use the editor's background color, not the background color of the hint itself. That means padding can be used to visually align/separate an inlay hint.",
          "type": "boolean"
        },
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position of this hint.\n\nIf multiple hints have the same position, they will be shown in the order they appear in the response."
        },
        "textEdits": {
          "description": "Optional text edits that are performed when accepting this inlay hint.\n\n*Note* that edits are expected to change the document so that the inlay hint (or its nearest variant) is now part of the document and the inlay hint itself is now obsolete.\n\nDepending on the client capability `inlayHint.resolveSupport` clients might resolve this property late using the resolve request.",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/TextEdit"
          },
          "type": "array"
        },
        "tooltip": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/MarkupContent"
            }
          ],
          "description": "The tooltip text when you hover over this item.\n\nDepending on the client capability `inlayHint.resolveSupport` clients might resolve this property late using the resolve request."
        }
      },
      "required": [
        "position",
        "label"
      ],
      "type": "object"
    },
    "InlayHintClientCapabilities": {
      "additionalProperties": false,
      "description": "Inlay hint client capabilities.",
      "properties": {
        "dynamicRegistration": {
          "description": "Whether inlay hints support dynamic registration.",
          "type": "boolean"
        },
        "resolveSupport": {
          "additionalProperties": false,
          "description": "Indicates which properties a client can resolve lazily on an inlay hint.",
          "properties": {
            "properties": {
              "description": "The properties that a client can resolve lazily.",
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          },
          "required": [
            "properties"
          ],
          "type": "object"
        }
      },
      "type": "object"
    },
    "InlayHintKind": {
      "description": "Inlay hint kinds.",
      "enum": [
        1,
        2
      ],
      "type": "number"
    },
    "InlayHintLabelPart": {
      "additionalProperties": false,
      "description": "An inlay hint label part allows for interactive and composite labels of inlay hints.",
      "properties": {
        "command": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Command",
          "description": "An optional command for this label part.\n\nDepending on the client capability `inlayHint.resolveSupport` clients might resolve this property late using the resolve request."
        },
        "location": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Location",
          "description": "An optional source code location that represents this label part.\n\nThe editor will use this location for the hover and for code navigation features: This part will become a clickable link that resolves to the definition of the symbol at the given location (not necessarily the location itself), it shows the hover that shows at the given location, and it shows a context menu with further code navigation commands.\n\nDepending on the client capability `inlayHint.resolveSupport` clients might resolve this property late using the resolve request."
        },
        "tooltip": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/MarkupContent"
            }
          ],
          "description": "The tooltip text when you hover over this label part. Depending on the client capability `inlayHint.resolveSupport` clients might resolve this property late using the resolve request."
        },
        "value": {
          "description": "The value of this label part.",
          "type": "string"
        }
      },
      "required": [
        "value"
      ],
      "type": "object"
    },
    "InlayHintOptions": {
      "additionalProperties": false,
      "description": "Inlay hint options used during static registration.",
      "properties": {
        "resolveProvider": {
          "description": "The server provides support to resolve additional information for an inlay hint item.",
          "type": "boolean"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "InlayHintParams": {
      "additionalProperties": false,
      "description": "A parameter literal used in inlay hint requests.",
      "properties": {
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The visible document range for which inlay hints should be computed."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument",
        "range"
      ],
      "type": "object"
    },
    "InlayHintRegistrationOptions": {
      "additionalProperties": false,
      "description": "Inlay hint options used during static or dynamic registration.",
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "id": {
          "description": "The id used to register the request. The id can be used to deregister the request again. See also Registration#id.",
          "type": "string"
        },
        "resolveProvider": {
          "description": "The server provides support to resolve additional information for an inlay hint item.",
          "type": "boolean"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "InlayHintWorkspaceClientCapabilities": {
      "additionalProperties": false,
      "description": "Client workspace capabilities specific to inlay hints.",
      "properties": {
        "refreshSupport": {
          "description": "Whether the client implementation supports a refresh request sent from the server to the client.\n\nNote that this event is global and will force the client to refresh all inlay hints currently shown. It should be used with absolute care and is useful for situation where a server for example detects a project wide change that requires such a calculation.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "InlineValue": {
      "anyOf": [
        {
          "$ref": "#/definitions/InlineValueText"
        },
        {
          "$ref": "#/definitions/InlineValueVariableLookup"
        },
        {
          "$ref": "#/definitions/InlineValueEvaluatableExpression"
        }
      ],
      "description": "Inline value information can be provided by different means:\n- directly as a text value (class InlineValueText).\n- as a name to use for a variable lookup (class InlineValueVariableLookup)\n- as an evaluatable expression (class InlineValueEvaluatableExpression) The InlineValue types combines all inline value types into one type."
    },
    "InlineValueClientCapabilities": {
      "additionalProperties": false,
      "description": "Client capabilities specific to inline values.",
      "properties": {
        "dynamicRegistration": {
          "description": "Whether implementation supports dynamic registration for inline value providers.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "InlineValueContext": {
      "additionalProperties": false,
      "properties": {
        "frameId": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/integer",
          "description": "The stack frame (as a DAP Id) where the execution has stopped."
        },
        "stoppedLocation": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The document range where execution has stopped. Typically the end position of the range denotes the line where the inline values are shown."
        }
      },
      "required": [
        "frameId",
        "stoppedLocation"
      ],
      "type": "object"
    },
    "InlineValueEvaluatableExpression": {
      "additionalProperties": false,
      "description": "Provide an inline value through an expression evaluation.\n\nIf only a range is specified, the expression will be extracted from the underlying document.\n\nAn optional expression can be used to override the extracted expression.",
      "properties": {
        "expression": {
          "description": "If specified the expression overrides the extracted expression.",
          "type": "string"
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The document range for which the inline value applies. The range is used to extract the evaluatable expression from the underlying document."
        }
      },
      "required": [
        "range"
      ],
      "type": "object"
    },
    "InlineValueOptions": {
      "additionalProperties": false,
      "description": "Inline value options used during static registration.",
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "InlineValueParams": {
      "additionalProperties": false,
      "description": "A parameter literal used in inline value requests.",
      "properties": {
        "context": {
          "$ref": "#/definitions/InlineValueContext",
          "description": "Additional information about the context in which inline values were requested."
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The document range for which inline values should be computed."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument",
        "range",
        "context"
      ],
      "type": "object"
    },
    "InlineValueRegistrationOptions": {
      "additionalProperties": false,
      "description": "Inline value options used during static or dynamic registration.",
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "id": {
          "description": "The id used to register the request. The id can be used to deregister the request again. See also Registration#id.",
          "type": "string"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "InlineValueText": {
      "additionalProperties": false,
      "description": "Provide inline value as text.",
      "properties": {
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The document range for which the inline value applies."
        },
        "text": {
          "description": "The text of the inline value.",
          "type": "string"
        }
      },
      "required": [
        "range",
        "text"
      ],
      "type": "object"
    },
    "InlineValueVariableLookup": {
      "additionalProperties": false,
      "description": "Provide inline value through a variable lookup.\n\nIf only a range is specified, the variable name will be extracted from the underlying document.\n\nAn optional variable name can be used to override the extracted name.",
      "properties": {
        "caseSensitiveLookup": {
          "description": "How to perform the lookup.",
          "type": "boolean"
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The document range for which the inline value applies. The range is used to extract the variable name from the underlying document."
        },
        "variableName": {
          "description": "If specified the name of the variable to look up.",
          "type": "string"
        }
      },
      "required": [
        "range",
        "caseSensitiveLookup"
      ],
      "type": "object"
    },
    "InlineValueWorkspaceClientCapabilities": {
      "additionalProperties": false,
      "description": "Client workspace capabilities specific to inline values.",
      "properties": {
        "refreshSupport": {
          "description": "Whether the client implementation supports a refresh request sent from the server to the client.\n\nNote that this event is global and will force the client to refresh all inline values currently shown. It should be used with absolute care and is useful for situation where a server for example detect a project wide change that requires such a calculation.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "InsertReplaceEdit": {
      "additionalProperties": false,
      "description": "A special text edit to provide an insert and a replace operation.",
      "properties": {
        "insert": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range if the insert is requested"
        },
        "newText": {
          "description": "The string to be inserted.",
          "type": "string"
        },
        "replace": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range if the replace is requested."
        }
      },
      "required": [
        "newText",
        "insert",
        "replace"
      ],
      "type": "object"
    },
    "InsertTextFormat": {
      "description": "Defines whether the insert text in a completion item should be interpreted as plain text or a snippet.",
      "enum": [
        1,
        2
      ],
      "type": "number"
    },
    "InsertTextMode": {
      "description": "How whitespace and indentation is handled during completion item insertion.",
      "enum": [
        1,
        2
      ],
      "type": "number"
    },
    "LinkedEditingRangeClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether the implementation supports dynamic registration. If this is set to `true` the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)` return value for the corresponding server capability as well.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LinkedEditingRangeOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "LinkedEditingRangeParams": {
      "additionalProperties": false,
      "properties": {
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "LinkedEditingRangeRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "id": {
          "description": "The id used to register the request. The id can be used to deregister the request again. See also Registration#id.",
          "type": "string"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "LinkedEditingRanges": {
      "additionalProperties": false,
      "properties": {
        "ranges": {
          "description": "A list of ranges that can be renamed together. The ranges must have identical length and contain identical text content. The ranges cannot overlap.",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/Range"
          },
          "type": "array"
        },
        "wordPattern": {
          "description": "An optional word pattern (regular expression) that describes valid contents for the given ranges. If no pattern is provided, the client configuration's word pattern will be used.",
          "type": "string"
        }
      },
      "required": [
        "ranges"
      ],
      "type": "object"
    },
    "MarkedString": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "additionalProperties": false,
          "properties": {
            "language": {
              "type": "string"
            },
            "value": {
              "type": "string"
            }
          },
          "required": [
            "language",
            "value"
          ],
          "type": "object"
        }
      ],
      "deprecated": "use MarkupContent instead.",
      "description": "MarkedString can be used to render human readable text. It is either a markdown string or a code-block that provides a language and a code snippet. The language identifier is semantically equal to the optional language identifier in fenced code blocks in GitHub issues.\n\nThe pair of a language and a value is an equivalent to markdown: ```${language} ${value} ```\n\nNote that markdown strings will be sanitized - that means html will be escaped."
    },
    "Moniker": {
      "additionalProperties": false,
      "description": "Moniker definition to match LSIF 0.5 moniker definition.",
      "properties": {
        "identifier": {
          "description": "The identifier of the moniker. The value is opaque in LSIF however schema owners are allowed to define the structure if they want.",
          "type": "string"
        },
        "kind": {
          "$ref": "#/definitions/MonikerKind",
          "description": "The moniker kind if known."
        },
        "scheme": {
          "description": "The scheme of the moniker. For example tsc or .Net",
          "type": "string"
        },
        "unique": {
          "$ref": "#/definitions/UniquenessLevel",
          "description": "The scope in which the moniker is unique"
        }
      },
      "required": [
        "scheme",
        "identifier",
        "unique"
      ],
      "type": "object"
    },
    "MonikerClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether implementation supports dynamic registration. If this is set to `true` the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)` return value for the corresponding server capability as well.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "MonikerKind": {
      "description": "The moniker kind.",
      "enum": [
        "import",
        "export",
        "local"
      ],
      "type": "string"
    },
    "MonikerOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "MonikerParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "MonikerRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "ParameterInformation": {
      "additionalProperties": false,
      "description": "Represents a parameter of a callable-signature. A parameter can have a label and a doc-comment.",
      "properties": {
        "documentation": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/MarkupContent"
            }
          ],
          "description": "The human-readable doc-comment of this parameter. Will be shown in the UI but can be omitted."
        },
        "label": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger"
              },
              "maxItems": 2,
              "minItems": 2,
              "type": "array"
            }
          ],
          "description": "The label of this parameter information.\n\nEither a string or an inclusive start and exclusive end offsets within its containing signature label. (see SignatureInformation.label). The offsets are based on a UTF-16 string representation as `Position` and `Range` does.\n\n*Note*: a label of type string should be a substring of its containing signature label. Its intended use case is to highlight the parameter label part in the `SignatureInformation.label`."
        }
      },
      "required": [
        "label"
      ],
      "type": "object"
    },
    "PrepareRenameParams": {
      "additionalProperties": false,
      "properties": {
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "PrepareSupportDefaultBehavior": {
      "enum": [
        1
      ],
      "type": "number"
    },
    "PreviousResultId": {
      "additionalProperties": false,
      "description": "A previous result id in a workspace pull request.",
      "properties": {
        "uri": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentUri",
          "description": "The URI for which the client knows a result id."
        },
        "value": {
          "description": "The value of the previous result id.",
          "type": "string"
        }
      },
      "required": [
        "uri",
        "value"
      ],
      "type": "object"
    },
    "PublishDiagnosticsClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "codeDescriptionSupport": {
          "description": "Client supports a codeDescription property",
          "type": "boolean"
        },
        "dataSupport": {
          "description": "Whether code action supports the `data` property which is preserved between a `textDocument/publishDiagnostics` and `textDocument/codeAction` request.",
          "type": "boolean"
        },
        "relatedInformation": {
          "description": "Whether the clients accepts diagnostics with related information.",
          "type": "boolean"
        },
        "tagSupport": {
          "additionalProperties": false,
          "description": "Client supports the tag property to provide meta data about a diagnostic. Clients supporting tags have to handle unknown tags gracefully.",
          "properties": {
            "valueSet": {
              "description": "The tags supported by the client.",
              "items": {
                "$ref": "../basicStructures/basicStructures.json#/definitions/DiagnosticTag"
              },
              "type": "array"
            }
          },
          "required": [
            "valueSet"
          ],
          "type": "object"
        },
        "versionSupport": {
          "description": "Whether the client interprets the version property of the `textDocument/publishDiagnostics` notification's parameter.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "PublishDiagnosticsParams": {
      "additionalProperties": false,
      "properties": {
        "diagnostics": {
          "description": "An array of diagnostic information items.",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/Diagnostic"
          },
          "type": "array"
        },
        "uri": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentUri",
          "description": "The URI for which diagnostic information is reported."
        },
        "version": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/integer",
          "description": "Optional the version number of the document the diagnostics are published for."
        }
      },
      "required": [
        "uri",
        "diagnostics"
      ],
      "type": "object"
    },
    "ReferenceClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether references supports dynamic registration.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ReferenceContext": {
      "additionalProperties": false,
      "properties": {
        "includeDeclaration": {
          "description": "Include the declaration of the current symbol.",
          "type": "boolean"
        }
      },
      "required": [
        "includeDeclaration"
      ],
      "type": "object"
    },
    "ReferenceOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "ReferenceParams": {
      "additionalProperties": false,
      "properties": {
        "context": {
          "$ref": "#/definitions/ReferenceContext"
        },
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "context",
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "ReferenceRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "RelatedFullDocumentDiagnosticReport": {
      "additionalProperties": false,
      "description": "A full diagnostic report with a set of related documents.",
      "properties": {
        "items": {
          "description": "The actual items.",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/Diagnostic"
          },
          "type": "array"
        },
        "kind": {
          "enum": [
            "full"
          ],
          "description": "A full document diagnostic report.",
          "type": "string"
        },
        "relatedDocuments": {
          "additionalProperties": {
            "anyOf": [
              {
                "$ref": "#/definitions/FullDocumentDiagnosticReport"
              },
              {
                "$ref": "#/definitions/UnchangedDocumentDiagnosticReport"
              }
            ]
          },
          "description": "Diagnostics of related documents. This information is useful in programming languages where code in a file A can generate diagnostics in a file B which A depends on. An example of such a language is C/C++ where macro definitions in a file a.cpp and result in errors in a header file b.hpp.",
          "type": "object"
        },
        "resultId": {
          "description": "An optional result id. If provided it will be sent on the next diagnostic request for the same document.",
          "type": "string"
        }
      },
      "required": [
        "items",
        "kind"
      ],
      "type": "object"
    },
    "RelatedUnchangedDocumentDiagnosticReport": {
      "additionalProperties": false,
      "description": "An unchanged diagnostic report with a set of related documents.",
      "properties": {
        "kind": {
          "enum": [
            "unchanged"
          ],
          "description": "A document diagnostic report indicating no changes to the last result. A server can only return `unchanged` if result ids are provided.",
          "type": "string"
        },
        "relatedDocuments": {
          "additionalProperties": {
            "anyOf": [
              {
                "$ref": "#/definitions/FullDocumentDiagnosticReport"
              },
              {
                "$ref": "#/definitions/UnchangedDocumentDiagnosticReport"
              }
            ]
          },
          "description": "Diagnostics of related documents. This information is useful in programming languages where code in a file A can generate diagnostics in a file B which A depends on. An example of such a language is C/C++ where macro definitions in a file a.cpp and result in errors in a header file b.hpp.",
          "type": "object"
        },
        "resultId": {
          "description": "A result id which will be sent on the next diagnostic request for the same document.",
          "type": "string"
        }
      },
      "required": [
        "kind",
        "resultId"
      ],
      "type": "object"
    },
    "RenameClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether rename supports dynamic registration.",
          "type": "boolean"
        },
        "honorsChangeAnnotations": {
          "description": "Whether the client honors the change annotations in text edits and resource operations returned via the rename request's workspace edit by for example presenting the workspace edit in the user interface and asking for confirmation.",
          "type": "boolean"
        },
        "prepareSupport": {
          "description": "Client supports testing for validity of rename operations before execution.",
          "type": "boolean"
        },
        "prepareSupportDefaultBehavior": {
          "$ref": "#/definitions/PrepareSupportDefaultBehavior",
          "description": "Client supports the default behavior result (`{ defaultBehavior: boolean }`).\n\nThe value indicates the default behavior used by the client."
        }
      },
      "type": "object"
    },
    "RenameOptions": {
      "additionalProperties": false,
      "properties": {
        "prepareProvider": {
          "description": "Renames should be checked and tested before being executed.",
          "type": "boolean"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "RenameParams": {
      "additionalProperties": false,
      "properties": {
        "newName": {
          "description": "The new name of the symbol. If the given name is not valid the request must return a [ResponseError](#ResponseError) with an appropriate message set.",
          "type": "string"
        },
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "newName",
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "RenameRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "prepareProvider": {
          "description": "Renames should be checked and tested before being executed.",
          "type": "boolean"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "SelectionRange": {
      "additionalProperties": false,
      "properties": {
        "parent": {
          "$ref": "#/definitions/SelectionRange",
          "description": "The parent selection range containing this range. Therefore `parent.range` must contain `this.range`."
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The [range](#Range) of this selection range."
        }
      },
      "required": [
        "range"
      ],
      "type": "object"
    },
    "SelectionRangeClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether implementation supports dynamic registration for selection range providers. If this is set to `true` the client supports the new `SelectionRangeRegistrationOptions` return value for the corresponding server capability as well.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SelectionRangeOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SelectionRangeParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "positions": {
          "description": "The positions inside the text document.",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/Position"
          },
          "type": "array"
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument",
        "positions"
      ],
      "type": "object"
    },
    "SelectionRangeRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "id": {
          "description": "The id used to register the request. The id can be used to deregister the request again. See also Registration#id.",
          "type": "string"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "SemanticTokenModifiers": {
      "enum": [
        "declaration",
        "definition",
        "readonly",
        "static",
        "deprecated",
        "abstract",
        "async",
        "modification",
        "documentation",
        "defaultLibrary"
      ],
      "type": "string"
    },
    "SemanticTokenTypes": {
      "enum": [
        "namespace",
        "type",
        "class",
        "enum",
        "interface",
        "struct",
        "typeParameter",
        "parameter",
        "variable",
        "property",
        "enumMember",
        "event",
        "function",
        "method",
        "macro",
        "keyword",
        "modifier",
        "comment",
        "string",
        "number",
        "regexp",
        "operator",
        "decorator"
      ],
      "type": "string"
    },
    "SemanticTokens": {
      "additionalProperties": false,
      "properties": {
        "data": {
          "description": "The actual tokens.",
          "items": {
            "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger"
          },
          "type": "array"
        },
        "resultId": {
          "description": "An optional result id. If provided and clients support delta updating the client will include the result id in the next semantic token request. A server can then instead of computing all semantic tokens again simply send a delta.",
          "type": "string"
        }
      },
      "required": [
        "data"
      ],
      "type": "object"
    },
    "SemanticTokensClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "augmentsSyntaxTokens": {
          "description": "Whether the client uses semantic tokens to augment existing syntax tokens. If set to `true` client side created syntax tokens and semantic tokens are both used for colorization. If set to `false` the client only uses the returned semantic tokens for colorization.\n\nIf the value is `undefined` then the client behavior is not specified.",
          "type": "boolean"
        },
        "dynamicRegistration": {
          "description": "Whether implementation supports dynamic registration. If this is set to `true` the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)` return value for the corresponding server capability as well.",
          "type": "boolean"
        },
        "formats": {
          "description": "The formats the clients supports.",
          "items": {
            "$ref": "#/definitions/TokenFormat"
          },
          "type": "array"
        },
        "multilineTokenSupport": {
          "description": "Whether the client supports tokens that can span multiple lines.",
          "type": "boolean"
        },
        "overlappingTokenSupport": {
          "description": "Whether the client supports tokens that can overlap each other.",
          "type": "boolean"
        },
        "requests": {
          "additionalProperties": false,
          "description": "Which requests the client supports and might send to the server depending on the server's capability. Please note that clients might not show semantic tokens or degrade some of the user experience if a range or full request is advertised by the client but not provided by the server. If for example the client capability `requests.full` and `request.range` are both set to true but the server only provides a range provider the client might not render a minimap correctly or might even decide to not show any semantic tokens at all.",
          "properties": {
            "full": {
              "title": "fullCapability",
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "additionalProperties": false,
                  "properties": {
                    "delta": {
                      "description": "The client will send the `textDocument/semanticTokens/full/delta` request if the server provides a corresponding handler.",
                      "type": "boolean"
                    }
                  },
                  "type": "object"
                }
              ],
              "description": "The client will send the `textDocument/semanticTokens/full` request if the server provides a corresponding handler."
            },
            "range": {
              "title": "rangeCapability",
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "additionalProperties": false,
                  "type": "object"
                }
              ],
              "description": "The client will send the `textDocument/semanticTokens/range` request if the server provides a corresponding handler."
            }
          },
          "type": "object"
        },
        "serverCancelSupport": {
          "description": "Whether the client allows the server to actively cancel a semantic token request, e.g. supports returning ErrorCodes.ServerCancelled. If a server does the client needs to retrigger the request.",
          "type": "boolean"
        },
        "tokenModifiers": {
          "description": "The token modifiers that the client supports.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "tokenTypes": {
          "description": "The token types that the client supports.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "requests",
        "tokenTypes",
        "tokenModifiers",
        "formats"
      ],
      "type": "object"
    },
    "SemanticTokensDelta": {
      "additionalProperties": false,
      "properties": {
        "edits": {
          "description": "The semantic token edits to transform a previous result into a new result.",
          "items": {
            "$ref": "#/definitions/SemanticTokensEdit"
          },
          "type": "array"
        },
        "resultId": {
          "type": "string"
        }
      },
      "required": [
        "edits"
      ],
      "type": "object"
    },
    "SemanticTokensDeltaParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "previousResultId": {
          "description": "The result id of a previous response. The result Id can either point to a full response or a delta response depending on what was received last.",
          "type": "string"
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument",
        "previousResultId"
      ],
      "type": "object"
    },
    "SemanticTokensDeltaPartialResult": {
      "additionalProperties": false,
      "properties": {
        "edits": {
          "items": {
            "$ref": "#/definitions/SemanticTokensEdit"
          },
          "type": "array"
        }
      },
      "required": [
        "edits"
      ],
      "type": "object"
    },
    "SemanticTokensEdit": {
      "additionalProperties": false,
      "properties": {
        "data": {
          "description": "The elements to insert.",
          "items": {
            "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger"
          },
          "type": "array"
        },
        "deleteCount": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger",
          "description": "The count of elements to remove."
        },
        "start": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger",
          "description": "The start offset of the edit."
        }
      },
      "required": [
        "start",
        "deleteCount"
      ],
      "type": "object"
    },
    "SemanticTokensLegend": {
      "additionalProperties": false,
      "properties": {
        "tokenModifiers": {
          "description": "The token modifiers a server uses.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "tokenTypes": {
          "description": "The token types a server uses.",
          "items": {
            "type": "string"
          },
          "type": "array"
        }
      },
      "required": [
        "tokenTypes",
        "tokenModifiers"
      ],
      "type": "object"
    },
    "SemanticTokensOptions": {
      "additionalProperties": false,
      "properties": {
        "full": {
          "title": "fullOption",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "additionalProperties": false,
              "properties": {
                "delta": {
                  "description": "The server supports deltas for full documents.",
                  "type": "boolean"
                }
              },
              "type": "object"
            }
          ],
          "description": "Server supports providing semantic tokens for a full document."
        },
        "legend": {
          "$ref": "#/definitions/SemanticTokensLegend",
          "description": "The legend used by the server"
        },
        "range": {
          "title": "rangeOption",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "additionalProperties": false,
              "type": "object"
            }
          ],
          "description": "Server supports providing semantic tokens for a specific range of a document."
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "legend"
      ],
      "type": "object"
    },
    "SemanticTokensParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument"
      ],
      "type": "object"
    },
    "SemanticTokensPartialResult": {
      "additionalProperties": false,
      "properties": {
        "data": {
          "items": {
            "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger"
          },
          "type": "array"
        }
      },
      "required": [
        "data"
      ],
      "type": "object"
    },
    "SemanticTokensRangeParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range the semantic tokens are requested for."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "textDocument",
        "range"
      ],
      "type": "object"
    },
    "SemanticTokensRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "full": {
          "title": "fullRegistrationOptions",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "additionalProperties": false,
              "properties": {
                "delta": {
                  "description": "The server supports deltas for full documents.",
                  "type": "boolean"
                }
              },
              "type": "object"
            }
          ],
          "description": "Server supports providing semantic tokens for a full document."
        },
        "id": {
          "description": "The id used to register the request. The id can be used to deregister the request again. See also Registration#id.",
          "type": "string"
        },
        "legend": {
          "$ref": "#/definitions/SemanticTokensLegend",
          "description": "The legend used by the server"
        },
        "range": {
          "title": "rangeRegistrationOption",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "additionalProperties": false,
              "type": "object"
            }
          ],
          "description": "Server supports providing semantic tokens for a specific range of a document."
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector",
        "legend"
      ],
      "type": "object"
    },
    "SemanticTokensWorkspaceClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "refreshSupport": {
          "description": "Whether the client implementation supports a refresh request sent from the server to the client.\n\nNote that this event is global and will force the client to refresh all semantic tokens currently shown. It should be used with absolute care and is useful for situation where a server for example detect a project wide change that requires such a calculation.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SignatureHelp": {
      "additionalProperties": false,
      "description": "Signature help represents the signature of something callable. There can be multiple signature but only one active and only one active parameter.",
      "properties": {
        "activeParameter": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger",
          "description": "The active parameter of the active signature. If omitted or the value lies outside the range of `signatures[activeSignature].parameters` defaults to 0 if the active signature has parameters. If the active signature has no parameters it is ignored. In future version of the protocol this property might become mandatory to better express the active parameter if the active signature does have any."
        },
        "activeSignature": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger",
          "description": "The active signature. If omitted or the value lies outside the range of `signatures` the value defaults to zero or is ignore if the `SignatureHelp` as no signatures.\n\nWhenever possible implementors should make an active decision about the active signature and shouldn't rely on a default value.\n\nIn future version of the protocol this property might become mandatory to better express this."
        },
        "signatures": {
          "description": "One or more signatures. If no signatures are available the signature help request should return `null`.",
          "items": {
            "$ref": "#/definitions/SignatureInformation"
          },
          "type": "array"
        }
      },
      "required": [
        "signatures"
      ],
      "type": "object"
    },
    "SignatureHelpClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "contextSupport": {
          "description": "The client supports to send additional context information for a `textDocument/signatureHelp` request. A client that opts into contextSupport will also support the `retriggerCharacters` on `SignatureHelpOptions`.",
          "type": "boolean"
        },
        "dynamicRegistration": {
          "description": "Whether signature help supports dynamic registration.",
          "type": "boolean"
        },
        "signatureInformation": {
          "additionalProperties": false,
          "description": "The client supports the following `SignatureInformation` specific properties.",
          "properties": {
            "activeParameterSupport": {
              "description": "The client supports the `activeParameter` property on `SignatureInformation` literal.",
              "type": "boolean"
            },
            "documentationFormat": {
              "description": "Client supports the follow content formats for the documentation property. The order describes the preferred format of the client.",
              "items": {
                "$ref": "../basicStructures/basicStructures.json#/definitions/MarkupKind"
              },
              "type": "array"
            },
            "parameterInformation": {
              "additionalProperties": false,
              "description": "Client capabilities specific to parameter information.",
              "properties": {
                "labelOffsetSupport": {
                  "description": "The client supports processing label offsets instead of a simple label string.",
                  "type": "boolean"
                }
              },
              "type": "object"
            }
          },
          "type": "object"
        }
      },
      "type": "object"
    },
    "SignatureHelpContext": {
      "additionalProperties": false,
      "description": "Additional information about the context in which a signature help request was triggered.",
      "properties": {
        "activeSignatureHelp": {
          "$ref": "#/definitions/SignatureHelp",
          "description": "The currently active `SignatureHelp`.\n\nThe `activeSignatureHelp` has its `SignatureHelp.activeSignature` field updated based on the user navigating through available signatures."
        },
        "isRetrigger": {
          "description": "`true` if signature help was already showing when it was triggered.\n\nRetriggers occur when the signature help is already active and can be caused by actions such as typing a trigger character, a cursor move, or document content changes.",
          "type": "boolean"
        },
        "triggerCharacter": {
          "description": "Character that caused signature help to be triggered.\n\nThis is undefined when triggerKind !== SignatureHelpTriggerKind.TriggerCharacter",
          "type": "string"
        },
        "triggerKind": {
          "$ref": "#/definitions/SignatureHelpTriggerKind",
          "description": "Action that caused signature help to be triggered."
        }
      },
      "required": [
        "triggerKind",
        "isRetrigger"
      ],
      "type": "object"
    },
    "SignatureHelpOptions": {
      "additionalProperties": false,
      "properties": {
        "retriggerCharacters": {
          "description": "List of characters that re-trigger signature help.\n\nThese trigger characters are only active when signature help is already showing. All trigger characters are also counted as re-trigger characters.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "triggerCharacters": {
          "description": "The characters that trigger signature help automatically.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "SignatureHelpParams": {
      "additionalProperties": false,
      "properties": {
        "context": {
          "$ref": "#/definitions/SignatureHelpContext",
          "description": "The signature help context. This is only available if the client specifies to send this using the client capability `textDocument.signatureHelp.contextSupport === true`"
        },
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "SignatureHelpRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "retriggerCharacters": {
          "description": "List of characters that re-trigger signature help.\n\nThese trigger characters are only active when signature help is already showing. All trigger characters are also counted as re-trigger characters.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "triggerCharacters": {
          "description": "The characters that trigger signature help automatically.",
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "SignatureHelpTriggerKind": {
      "description": "How a signature help was triggered.",
      "enum": [
        1,
        2,
        3
      ],
      "type": "number"
    },
    "SignatureInformation": {
      "additionalProperties": false,
      "description": "Represents the signature of something callable. A signature can have a label, like a function-name, a doc-comment, and a set of parameters.",
      "properties": {
        "activeParameter": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/uinteger",
          "description": "The index of the active parameter.\n\nIf provided, this is used in place of `SignatureHelp.activeParameter`."
        },
        "documentation": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/MarkupContent"
            }
          ],
          "description": "The human-readable doc-comment of this signature. Will be shown in the UI but can be omitted."
        },
        "label": {
          "description": "The label of this signature. Will be shown in the UI.",
          "type": "string"
        },
        "parameters": {
          "description": "The parameters of this signature.",
          "items": {
            "$ref": "#/definitions/ParameterInformation"
          },
          "type": "array"
        }
      },
      "required": [
        "label"
      ],
      "type": "object"
    },
    "SymbolInformation": {
      "additionalProperties": false,
      "deprecated": "use DocumentSymbol or WorkspaceSymbol instead.",
      "description": "Represents information about programming constructs like variables, classes, interfaces etc.",
      "properties": {
        "containerName": {
          "description": "The name of the symbol containing this symbol. This information is for user interface purposes (e.g. to render a qualifier in the user interface if necessary). It can't be used to re-infer a hierarchy for the document symbols.",
          "type": "string"
        },
        "deprecated": {
          "deprecated": "Use tags instead",
          "description": "Indicates if this symbol is deprecated.",
          "type": "boolean"
        },
        "kind": {
          "$ref": "#/definitions/SymbolKind",
          "description": "The kind of this symbol."
        },
        "location": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Location",
          "description": "The location of this symbol. The location's range is used by a tool to reveal the location in the editor. If the symbol is selected in the tool the range's start information is used to position the cursor. So the range usually spans more then the actual symbol's name and does normally include things like visibility modifiers.\n\nThe range doesn't have to denote a node range in the sense of an abstract syntax tree. It can therefore not be used to re-construct a hierarchy of the symbols."
        },
        "name": {
          "description": "The name of this symbol.",
          "type": "string"
        },
        "tags": {
          "description": "Tags for this symbol.",
          "items": {
            "$ref": "#/definitions/SymbolTag"
          },
          "type": "array"
        }
      },
      "required": [
        "name",
        "kind",
        "location"
      ],
      "type": "object"
    },
    "SymbolKind": {
      "description": "A symbol kind.",
      "enum": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26
      ],
      "type": "number"
    },
    "SymbolTag": {
      "enum": [
        1
      ],
      "description": "Symbol tags are extra annotations that tweak the rendering of a symbol.",
      "type": "number"
    },
    "TokenFormat": {
      "enum": [
        "relative"
      ],
      "type": "string"
    },
    "TypeDefinitionClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether implementation supports dynamic registration. If this is set to `true` the client supports the new `TypeDefinitionRegistrationOptions` return value for the corresponding server capability as well.",
          "type": "boolean"
        },
        "linkSupport": {
          "description": "The client supports additional metadata in the form of definition links.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TypeDefinitionOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TypeDefinitionParams": {
      "additionalProperties": false,
      "properties": {
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "TypeDefinitionRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "id": {
          "description": "The id used to register the request. The id can be used to deregister the request again. See also Registration#id.",
          "type": "string"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "TypeHierarchyClientCapabilities": {
      "additionalProperties": false,
      "properties": {
        "dynamicRegistration": {
          "description": "Whether implementation supports dynamic registration. If this is set to `true` the client supports the new `(TextDocumentRegistrationOptions &amp; StaticRegistrationOptions)` return value for the corresponding server capability as well.",
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TypeHierarchyItem": {
      "additionalProperties": false,
      "properties": {
        "data": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/LSPAny",
          "description": "A data entry field that is preserved between a type hierarchy prepare and supertypes or subtypes requests. It could also be used to identify the type hierarchy in the server, helping improve the performance on resolving supertypes and subtypes."
        },
        "detail": {
          "description": "More detail for this item, e.g. the signature of a function.",
          "type": "string"
        },
        "kind": {
          "$ref": "#/definitions/SymbolKind",
          "description": "The kind of this item."
        },
        "name": {
          "description": "The name of this item.",
          "type": "string"
        },
        "range": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code."
        },
        "selectionRange": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Range",
          "description": "The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function. Must be contained by the [`range`](#TypeHierarchyItem.range)."
        },
        "tags": {
          "description": "Tags for this item.",
          "items": {
            "$ref": "#/definitions/SymbolTag"
          },
          "type": "array"
        },
        "uri": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentUri",
          "description": "The resource identifier of this item."
        }
      },
      "required": [
        "name",
        "kind",
        "uri",
        "range",
        "selectionRange"
      ],
      "type": "object"
    },
    "TypeHierarchyOptions": {
      "additionalProperties": false,
      "properties": {
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "TypeHierarchyPrepareParams": {
      "additionalProperties": false,
      "properties": {
        "position": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/Position",
          "description": "The position inside the text document."
        },
        "textDocument": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/TextDocumentIdentifier",
          "description": "The text document."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "position",
        "textDocument"
      ],
      "type": "object"
    },
    "TypeHierarchyRegistrationOptions": {
      "additionalProperties": false,
      "properties": {
        "documentSelector": {
          "anyOf": [
            {
              "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentSelector"
            },
            {
              "type": "null"
            }
          ],
          "description": "A document selector to identify the scope of the registration. If set to null the document selector provided on the client side will be used."
        },
        "id": {
          "description": "The id used to register the request. The id can be used to deregister the request again. See also Registration#id.",
          "type": "string"
        },
        "workDoneProgress": {
          "type": "boolean"
        }
      },
      "required": [
        "documentSelector"
      ],
      "type": "object"
    },
    "TypeHierarchySubtypesParams": {
      "additionalProperties": false,
      "properties": {
        "item": {
          "$ref": "#/definitions/TypeHierarchyItem"
        },
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "item"
      ],
      "type": "object"
    },
    "TypeHierarchySupertypesParams": {
      "additionalProperties": false,
      "properties": {
        "item": {
          "$ref": "#/definitions/TypeHierarchyItem"
        },
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "item"
      ],
      "type": "object"
    },
    "UnchangedDocumentDiagnosticReport": {
      "additionalProperties": false,
      "description": "A diagnostic report indicating that the last returned report is still accurate.",
      "properties": {
        "kind": {
          "enum": [
            "unchanged"
          ],
          "description": "A document diagnostic report indicating no changes to the last result. A server can only return `unchanged` if result ids are provided.",
          "type": "string"
        },
        "resultId": {
          "description": "A result id which will be sent on the next diagnostic request for the same document.",
          "type": "string"
        }
      },
      "required": [
        "kind",
        "resultId"
      ],
      "type": "object"
    },
    "UniquenessLevel": {
      "description": "Moniker uniqueness level to define scope of the moniker.",
      "enum": [
        "document",
        "project",
        "group",
        "scheme",
        "global"
      ],
      "type": "string"
    },
    "WorkspaceDiagnosticParams": {
      "additionalProperties": false,
      "description": "Parameters of the workspace diagnostic request.",
      "properties": {
        "identifier": {
          "description": "The additional identifier provided during registration.",
          "type": "string"
        },
        "partialResultToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report partial results (e.g. streaming) to the client."
        },
        "previousResultIds": {
          "description": "The currently known diagnostic reports with their previous result ids.",
          "items": {
            "$ref": "#/definitions/PreviousResultId"
          },
          "type": "array"
        },
        "workDoneToken": {
          "$ref": "../baseProtocol/baseProtocol.json#/definitions/ProgressToken",
          "description": "An optional token that a server can use to report work done progress."
        }
      },
      "required": [
        "previousResultIds"
      ],
      "type": "object"
    },
    "WorkspaceDiagnosticReport": {
      "additionalProperties": false,
      "description": "A workspace diagnostic report.",
      "properties": {
        "items": {
          "items": {
            "$ref": "#/definitions/WorkspaceDocumentDiagnosticReport"
          },
          "type": "array"
        }
      },
      "required": [
        "items"
      ],
      "type": "object"
    },
    "WorkspaceDiagnosticReportPartialResult": {
      "additionalProperties": false,
      "description": "A partial result for a workspace diagnostic report.",
      "properties": {
        "items": {
          "items": {
            "$ref": "#/definitions/WorkspaceDocumentDiagnosticReport"
          },
          "type": "array"
        }
      },
      "required": [
        "items"
      ],
      "type": "object"
    },
    "WorkspaceDocumentDiagnosticReport": {
      "anyOf": [
        {
          "$ref": "#/definitions/WorkspaceFullDocumentDiagnosticReport"
        },
        {
          "$ref": "#/definitions/WorkspaceUnchangedDocumentDiagnosticReport"
        }
      ],
      "description": "A workspace diagnostic document report."
    },
    "WorkspaceFullDocumentDiagnosticReport": {
      "additionalProperties": false,
      "description": "A full document diagnostic report for a workspace diagnostic result.",
      "properties": {
        "items": {
          "description": "The actual items.",
          "items": {
            "$ref": "../basicStructures/basicStructures.json#/definitions/Diagnostic"
          },
          "type": "array"
        },
        "kind": {
          "enum": [
            "full"
          ],
          "description": "A full document diagnostic report.",
          "type": "string"
        },
        "resultId": {
          "description": "An optional result id. If provided it will be sent on the next diagnostic request for the same document.",
          "type": "string"
        },
        "uri": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentUri",
          "description": "The URI for which diagnostic information is reported."
        },
        "version": {
          "anyOf": [
            {
              "$ref": "../baseProtocol/baseProtocol.json#/definitions/integer"
            },
            {
              "type": "null"
            }
          ],
          "description": "The version number for which the diagnostics are reported. If the document is not marked as open `null` can be provided."
        }
      },
      "required": [
        "items",
        "kind",
        "uri",
        "version"
      ],
      "type": "object"
    },
    "WorkspaceUnchangedDocumentDiagnosticReport": {
      "additionalProperties": false,
      "description": "An unchanged document diagnostic report for a workspace diagnostic result.",
      "properties": {
        "kind": {
          "enum": [
            "unchanged"
          ],
          "description": "A document diagnostic report indicating no changes to the last result. A server can only return `unchanged` if result ids are provided.",
          "type": "string"
        },
        "resultId": {
          "description": "A result id which will be sent on the next diagnostic request for the same document.",
          "type": "string"
        },
        "uri": {
          "$ref": "../basicStructures/basicStructures.json#/definitions/DocumentUri",
          "description": "The URI for which diagnostic information is reported."
        },
        "version": {
          "anyOf": [
            {
              "$ref": "../baseProtocol/baseProtocol.json#/definitions/integer"
            },
            {
              "type": "null"
            }
          ],
          "description": "The version number for which the diagnostics are reported. If the document is not marked as open `null` can be provided."
        }
      },
      "required": [
        "kind",
        "resultId",
        "uri",
        "version"
      ],
      "type": "object"
    }
  }
}
